"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lines = _interopRequireDefault(require("./common/lines"));

var _extractToken = _interopRequireDefault(require("./common/extractToken"));

var _reduceGemDeps = _interopRequireDefault(require("./common/reduceGemDeps"));

var _constants = require("./common/constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var odds = function odds(_, i) {
  return i % 2 !== 0;
};

var isEven = function isEven(i) {
  return i % 2 === 0;
};

var findOtherGroupRanges = function findOtherGroupRanges() {
  var lines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return lines.map(function (line, index) {
    return {
      line: line.trim(),
      index: index
    };
  }).filter(function (_ref) {
    var line = _ref.line;
    return line.startsWith('group') || line === 'end';
  }).reduce(function (acc, _ref2, i) {
    var line = _ref2.line,
        index = _ref2.index;
    return _toConsumableArray(acc).concat([isEven(i) ? {
      name: (0, _extractToken.default)(line, {
        start: 'group',
        end: 'do'
      }),
      start: index
    } : _objectSpread({}, acc[i - 1], {
      end: index
    })]);
  }, []).filter(odds);
};

var _default = function _default() {
  var gemfile = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  var appGemfileFilter = function appGemfileFilter(l) {
    return l.trim().startsWith(_constants.gemDependencyToken) || l.startsWith('group') || l.startsWith('end');
  };

  var endOfHeader = gemfile.indexOf(_constants.gemDependencyToken);
  var header = gemfile.slice(0, endOfHeader);
  var lines = (0, _lines.default)(gemfile).filter(appGemfileFilter);
  var otherGroupRanges = findOtherGroupRanges(lines);
  var endOfDefaultGroup = otherGroupRanges.length > 0 ? otherGroupRanges[0].start : lines.length;
  var defaultGroup = (0, _reduceGemDeps.default)(lines.slice(0, endOfDefaultGroup));
  var otherGroups = otherGroupRanges.reduce(function (acc, _ref3) {
    var name = _ref3.name,
        start = _ref3.start,
        end = _ref3.end;
    return _objectSpread({}, acc, _defineProperty({}, name, (0, _reduceGemDeps.default)(lines.slice(start + 1, end))));
  }, {});
  return {
    header: header,
    defaultGroup: defaultGroup,
    otherGroups: otherGroups
  };
};

exports.default = _default;